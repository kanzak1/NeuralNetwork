# NeuralNetwork
Федеральное агентство по образованию
Ульяновский государственный технический университет
Факультет информационных систем и технологий
Кафедра «Вычислительная техника»
Дисциплина «Алгоритмы и структуры данных»





Пояснительная записка
Тема курсовой работы: «Искусственная нейронная сеть»





Выполнил:
студент группы ИВТВМбд-21
Салахов А.И.
Проверил:
Фолунин В.А.

Ульяновск, 2017

Содержание
1. Техническое задание.
1.1. Индивидуальное задание.
2. Техническое проектирование.
2.1. UML-диаграмма классов с комментариями.
2.2. Описание взаимодействия классов.
2.3. Javadoc.
3. Алгоритмические обеспечение.
3.1. Описание используемых алгоритмов и их назначения.
3.2. Теоретическое обоснование сложности.
3.3. Эмпирическое обоснование сложности.
4. Тестирование.
4.1. Описание unit-тестов.
5. Выводы.
6. Приложения.
6.1. Приложение 1. Руководство пользователя.
6.2. Приложение 2. Исходный код.








1. Техническое задание.
1.1. Общее техническое задание.
Требуется написать приложение, распознающее образы из видеофайла с помощью искусственной нейронной сети, используя метод обратного распространения ошибки
Входные данные :
Видео файл
Критерии для видеофайла :
1) Неограниченность во времени
2) В образе не должно быть более 1 символа
3) Цвета фона и символа в образе могут быть любыми
4) Размер изображений в видеофайле должен быть равным 255x255
1.2  Индивидуальное задание.
Необходимо создать искусственную нейронную сеть, а именно парцептрон, с одним скрытым слоем, в котором происходит обучение при помощи алгоритма обратного распространения ошибки. В данном алгоритме используется сигмоидальная функция активации, а именно функция Ферми (экспоненциальная сигмоида):  , где 
s – значение элемента, полученного из матричного кода, который соответствует пикселю (0 или 1);
a – коэффициент “сглаживания” сигмоидальной функции (alpha).
Рис. 1. Экспоненциальная сигмоида
Для определения полученного образа необходимо использовать метод наименьшей среднеквадратичной ошибки (Root Mean Squared Error).
Формула RMSE:
 , где
n – количество пикселей;
  - i-й элемент матричного кода, который соответствует пикселю эталонного образа;
  - i-й элемент матричного кода, который соответствует пикселю полученного образа. 
Этапы в создании ИНС:
1) Определить алгоритм распознавания образов через нейронную сеть
2) Выбрать один из способов обучения нейронной сети
3) Написать классы, один из которых отвечает за создание одного нейрона, его обучение и вычисление среднеквадратичной ошибки, а также класс, который создаёт сеть нейронов, сохраняет её для будущего использования и определяет, какой из нейронов больше подходит под образ
Для тренировки нейронной сети и обработки видео файла создаются следующие классы :
1) Класс, необходимый для обработки одного изображения, а также определения цвета фона и символа
2) Класс, отвечающий за раскадровку видеофайла, а также вывода результата по каждому взятому из него образу

2. Техническое проектирование.
2.1. UML-диаграмма классов с комментариями.
 
В проекте присутствуют 6 классов :
1. Program.cs
    Класс для запуска программы
2. neuron.cs
Класс нейронов. Содержит в себе методы : для создания одного инициализированного нейрона; для тренировки выбранного нейрона по необходимому образу с помощью экспоненциальной функции активации; для расчёта среднеквадратичного отклонения весов нейрона от весов входного образа;


Переменные :
•	public const double a = 1.0; // коэффициент альфа типа double, применяется для расчёта    функции активации (модификатор доступа - public)
•	public string name; // имя нейрона типа string (модификатор доступа - public)
•	public int count; // число обучений нейрона типа integer (модификатор доступа - public)
•	public double[,] weight; // двумерный массив весов нейрона типа double (модификатор доступа - public)
Методы :
•	public void training(double[,] form) // void функция, тренирующая нейрон по     входному изображению с помощью функции активации (модификатор доступа - public)
•	public double MSE(double[,] w) // double функция, высчитывающая среднеквадратинчое отклонение весов нейрона от весов входного изображения (модификатор доступа - public)
•	public neuron CreateN(string s) // функция типа neuron, которая создаёт нейрон по строке s (модификатор доступа - public)
3.web.cs
    Класс, обрабатывающий сеть нейронов. Сеть создаётся с помощью текстового файла, в котором хранится информация о раннее созданных нейронах; также в классе используются методы для сохранения н.с. в текстовый файл, обучения одного нейрона из н.с.и определения результата входного образа нейронной сетью.
Переменные:
•	public List<neuron> nnet; // экземпляр List<neuron> nnet (модификатор доступа - public)
•	public const string f = @"memory.txt"; // путь к файлу memory.txt


Методы:
•	public web() // конструктор класса web
•	public List<neuron> CreateNetwork() // функция, необходимая для создания нейронной сети
•	public void save() // функция, сохраняющая сеть нейронов в текстовый файл
•	public void training(string nameofneur, double[,] form) // функция, тренирующая  нейрон из нейронной сети по определённому имени и массиву весов
•	public string determinant(double[,] w) // функция, сравнивающая нейроны с изображением	
4.picture.cs
    Класс, обрабатывающий изображение. Содержит в себе методы для проверки отклонения цветов от граничного значения, преобразования картинки в массив весов, сужения и расширения изображения, а также для обрезки Bitmap картинки по краям символа
Переменные :
•	public Color Cbgr;  // переменная типа Color, служащая для хранения цвета фона (модификатор доступа - public)
•	public int srR = 0; // переменная типа integer, необходимая для расчёта приближённого красного оттенка цвета символа (среднее значение)
•	public int srG = 0; // переменная типа integer, необходимая для расчёта приближённого зелёного оттенка цвета символа (среднее значение)
•	public int srB = 0; // переменная типа integer, необходимая для расчёта приближённого синего оттенка цвета символа (среднее значение)
•	public int srA = 0; // переменная типа integer, необходимая для расчёта приближённого значения прозрачности цвета символа (среднее значение)
•	public Bitmap img, cimg, resimg; // переменные типа Bitmap : img - начального изображения cimg - обрезанного изображения resimg - конечного изображения (модификатор доступа - public)
•	public double[,] imgarr; // двумерный массив весов начального изображения типа double (модификатор доступа - public)
•	public double[,] arrnumb = new double[20, 20]; // двумерный массив весов конечного изображения типа double размерностью 20x20 (модификатор доступа - public)
•	public string filename; // путь к изображению для Bitmap img (модификатор доступа - public)
•	public int x1, y1, x2, y2; // переменные типа integer, необходимые для хранения координат левой верхней и правой нижней точек символа (модификатор доступа - public)
•	Random rand = new Random(); // экземпляр класса random, необходимый для получения случайных чисел
•	public const int COLOR_THRESHOLD = 64; // переменная типа integer, являющаяся границей для определения цвета (модификаторы - public const)
Методы :
•	public static bool equal(Color a, Color b, int threshold) // функция типа boolean, которая проверяет, не вышел ли цвет за максимально допустимое значение treshold (модификатор доступа - public)
•	public picture(string filename) // конструктор класса picture (модификатор доступа - public)
•	public double[,] BitmapToArr(double[,] arr, Bitmap img) // double функция, преобразующая Bitmap изображение в массив весов (модификатор доступа - public)
•	  public void ImgProc() // функция, необходимая для обработки изображения (нахождение координат левой верхней и правой нижней точек символа; обрезка изображения по полученным координатам; получение конечного изображения размера 20x20 из обрезанного)
•	public Bitmap const_exp() // функция, по необходимости сужающая или расширяющая обрезанное изображение

5.video.cs
    Класс, предназначенный для обработки видеофайлов. Делит его на кадры, предоставляет краткую информацию об обрабатываемом файле, а также сохраняет результат сравнения каждого кадра из видеофайла с нейронами из и.н.с.
Переменные :
	 public List<picture> videoweb = new List<picture>(); // экземпляр List<picture> для хранения кадров видеофайла (модификатор доступа - public)
        public VideoFileReader reader = new VideoFileReader(); // экземпляр VideoFileReader для считывания кадров из видеофайла и получения дополнительной информации о нём (модификатор доступа - public)
        public int index; // переменная типа integer, необходимая для хранения индекса последнего сохранённого изображения (модификатор доступа - public)
        int count = 0; int width, heigth, fps; string codec;  // count integer - счётчик (считающий кол-во обрабатываемых кадров из видеофайла), integer width - информация о ширине видеофайла, integer heigth - информация о высоте видеофайла, integer fps - информация о частоте кадров в секунду, string codec - информация о кодеке
        const string file = @"index.txt"; // переменная const string, хранящая путь к файлу, в котором содержится значение индекса последнего сохранённого изображения.
        long frameCount; // переменная типа long, необходимая для хранения кол-ва кадров в видеофале
Методы :
        public video(string filename) // конструктор класса video
        public List<picture> raskadrovka() // функция, которая получает информацию о видеофайле и делит его на кадры, которые обрабатываются в классе picture и записываются в лист
        public string resultat(web web) // функция, необходимая для вывода результатов сравнения нейронов из нейронной сети с каждым из образов, полученных из видеофайла
        public void Dispose() // функция, обрабатывающая исключение NotImplementedException
6.Form3.cs 
    класс, который выводит главное окно, созданного при помощи Windows Forms, для работы с искусственной нейронной сетью.
Переменные :
•	web web = new web(); // создание экземпляра класса web (создание нейронной сети)
•	video video = null; // экземпляр класса video равный null
•	string text = ""; // переменная string, которая должна получить результат 
•	string filetrain = ""; picture train; string nametrain = ""; // filetrain - переменная string, необходимая для хранения пути к образу, которому мы хотим научить нейронную сеть; train - экземпляр класса picture, служащая для хранения изображения; string nametrain - имя тренируемого нейрона; 
•	string videoname; // путь к видео файлу
Методы :
•	public Form3() // конструктор класса Form3
•	private void button3_Click(object sender, EventArgs e) // функция, обрабатывающая нажатие кнопки button3
•	private void button1_Click(object sender, EventArgs e) // функция, обрабатывающая нажатие кнопки button1
•	private void button2_Click(object sender, EventArgs e) // функция, обрабатывающая нажатие кнопки button2
•	private void textBox2_TextChanged(object sender, EventArgs e) // метод, обрабатывающий изменение текста поля textBox2
•	private void textBox1_TextChanged(object sender, EventArgs e) // функция, обрабатывающая изменение текста поля textBox1	
•	private void Form3_Load(object sender, EventArgs e) // метод, загружающий Form3

2.2. Описание взаимодействия классов.
В начале работы программы загружается класс «program.cs» и выполняется метод, вызывающий интерфейс, в нём создаётся экземпляр класса «web.cs», вместе с этим из текстового файла с именем «memory.txt» берутся данные о ранее созданных нейронах и по ним создаётся и.н.с., обращаясь к классу «neuron.cs», который создаёт каждый нейрон в отдельности. При загрузке видеофайла в интерфейсе создаётся экземпляр класса «video.cs», в котором по конструктору вызывается метод, разбивающий файл на список кадров («raskadrovka()»), каждый из которых обрабатывается классом «picture». В итоге вызывается метод «video.resultat()» и в  поле «TextBox2» можно увидеть результат обработки видеофайла.
Связь между классами прослеживается следующая :
В «Form3.cs» имеется связь со всеми классами (создание нейросети, обработка видеофайла, тренировка нейрона и.т.д.). Класс «web.cs» связан с «neuron.cs» (создание нейрона и его запись в и.н.с., тренировка нейрона, получение результата сравнения входного образа с и.н.с.). Класс «video» связан с классом «picture» (видеофайл делится на кадры и по каждому из них создаётся экземпляр класса «picture.cs» для получения результирующего массива весов). Остаётся класс «program.cs», в котором собирается программа и вызывается интерфейс
Между классами «neuron» и «web» - агрегация («web»  - контейнер, «neuron» - содержимое)
Между классами «picture» и «video» - агрегация («video» - контейнер «picture» - содержимое)
Между классами «Form3» и «Program» - зависимость («Program» зависит от «Form3»)
Между классами «Form3» и «web» - зависимость («Form3» зависит от «web»)
Между классами «Form3» и «video» - зависимость ((«Form3» зависит от «video»)
2.3. Javadoc.
Класс WindowsFormsApplication4.Form3
Открытые члены
•	Form3 ()
Защищенные члены
•	override void Dispose (bool disposing)
Clean up any resources being used. 

Подробное описание
класс интерфейса 

Конструктор(ы)
WindowsFormsApplication4.Form3.Form3 ()
конструктор класса Form3 

Методы
override void WindowsFormsApplication4.Form3.Dispose (bool  disposing)[protected]

Clean up any resources being used. 

Аргументы:
disposing 	true if managed resources should be disposed; otherwise, false.

Объявления и описания членов классов находятся в файлах:
•	Form3.cs
•	Form3.Designer.cs

Класс WindowsFormsApplication4.neuron
Открытые члены
•	void training (double[,] form)
•	double MSE (double[,] w)
•	neuron CreateN (string s)
Открытые атрибуты
•	const double a = 1.0
коэффициент альфа, применяется для расчёта функции активации 
•	string name
имя нейрона типа string. 
•	int count
число обучений нейрона 
•	double [,] weight
двумерный массив весов нейрона 

Подробное описание
класс нейрона 

Методы
neuron WindowsFormsApplication4.neuron.CreateN (string  s)
функция, которая создаёт нейрон по строке s 
Аргументы:
s 	строка, по которой будет создаваться нейрон 
Возвращает:
this полученный нейрон 
double WindowsFormsApplication4.neuron.MSE (double  w[,])
double функция, высчитывающая среднеквадратинчое отклонение весов нейрона от весов входного изображения 
Аргументы:
w 	Массив весов образа 
Возвращает:
sum результат среднеквадратичного отклонения 
void WindowsFormsApplication4.neuron.training (double  form[,])
функция, тренирующая нейрон по входному изображению с помощью функции активации 
Аргументы:
form 	Массив весов образа 

Объявления и описания членов класса находятся в файле:
•	neuron.cs

Класс WindowsFormsApplication4.picture
Открытые члены
•	picture (string filename)
•	double [,] BitmapToArr (Bitmap img)
•	void ImgProc ()
•	Bitmap CutImg ()
•	Bitmap const_exp ()
Открытые статические члены
•	static bool equal (Color a, Color b, int threshold)
Открытые атрибуты
•	Color Cbgr
переменная, служащая для хранения цвета фона 
•	int srR = 0
переменная, необходимая для расчёта приближённого красного оттенка цвета символа (среднее значение) 
•	int srG = 0
переменная, необходимая для расчёта приближённого зелёного оттенка цвета символа (среднее значение) 
•	int srB = 0
переменная, необходимая для расчёта приближённого синего оттенка цвета символа (среднее значение) 
•	int srA = 0
переменная, необходимая для расчёта приближённого значения прозрачности цвета символа (среднее значение) 
•	Bitmap img
переменная для хранения начального изображения 
•	Bitmap cimg
переменная для хранения обрезанного изображения 
•	Bitmap resimg
переменная для хранения конечного изображения 
•	double [,] imgarr
двумерный массив весов начального изображения 
•	double [,] arrnumb = new double[20, 20]
двумерный массив весов конечного изображения размерностью 20x20. 
•	string filename
путь к изображению для Bitmap img. 
•	int x1
переменные типа integer, необходимые для хранения координат левой верхней и правой нижней точек символа 
•	const int COLOR_THRESHOLD = 64
переменная, являющаяся границей для определения цвета 

Подробное описание
класс, обрабатывающий изображение 

 
Конструктор(ы)
WindowsFormsApplication4.picture.picture (string  filename)
конструктор класса picture 
Аргументы:
filename 	путь к изображению 

Методы
double [,] WindowsFormsApplication4.picture.BitmapToArr (Bitmap  img)
double функция, преобразующая Bitmap изображение в массив весов 
Аргументы:
img 	изображение, которое нужно преобразовать в массив весов 
Bitmap WindowsFormsApplication4.picture.const_exp ()
функция, по необходимости сужающая или расширяющая обрезанное изображение 
Bitmap WindowsFormsApplication4.picture.CutImg ()
функция, обрезающая изображение 
static bool WindowsFormsApplication4.picture.equal (Color  a, Color  b, int  threshold)[static]
функция, которая проверяет, не вышел ли цвет за максимально допустимое значение treshold 
Аргументы:
a 	переменная, хранящая цвет, для сравнения с переменной "b" 
b 	2ая переменная, хранящая цвет, для сравнения с переменной "a" 
threshold 	граничное значение 
Возвращает:
возвращение результата проверки функции 
void WindowsFormsApplication4.picture.ImgProc ()
double функция, необходимая для обработки изображения (нахождение координат левой верхней и правой нижней точек символа; обрезка изображения по полученным координатам; получение конечного изображения размера 20x20 из обрезанного) 

Объявления и описания членов класса находятся в файле:
•	picture.cs

 
Класс WindowsFormsApplication4.video
Открытые члены
•	video (string filename)
•	List< picture > raskadrovka ()
•	string resultat (web web)
•	void Dispose ()
Открытые атрибуты
•	List< picture > videoweb = new List<picture>()
экземпляр List<picture> для хранения кадров видеофайла 
•	VideoFileReader reader = new VideoFileReader()
экземпляр VideoFileReader для считывания кадров из видеофайла и получения дополнительной информации о нём 
•	int index
переменная типа integer, необходимая для хранения индекса последнего сохранённого изображения 

Подробное описание
класс, предназначенный для обработки видеофайлов 

Конструктор(ы)
WindowsFormsApplication4.video.video (string  filename)
конструктор класса video 
Аргументы:
filename 	путь к видеофайлу 

Методы
void WindowsFormsApplication4.video.Dispose ()
функция, необходимая для очищения ресурсов 
List<picture> WindowsFormsApplication4.video.raskadrovka ()
функция, которая получает информацию о видеофайле и делит его на кадры, которые обрабатываются в классе picture и записываются в лист 
string WindowsFormsApplication4.video.resultat (web  web)
функция, необходимая для вывода результатов сравнения нейронов из нейронной сети с каждым из образов, полученных из видеофайла 
Аргументы:
web 	нейронная сеть 

Объявления и описания членов класса находятся в файле:
 
•	video.cs

Класс WindowsFormsApplication4.web
Открытые члены
•	web ()
•	List< neuron > CreateNetwork ()
•	void save ()
•	void training (string nameofneur, double[,] form)
•	string determinant (double[,] w)
Открытые атрибуты
•	List< neuron > nnet
экземпляр List<neuron> nnet. 
•	const string f = @"memory.txt"
путь к файлу memory.txt. 

Подробное описание
класс, обрабатывающий сеть нейронов 

Конструктор(ы)
WindowsFormsApplication4.web.web ()
конструктор класса web 

Методы
List<neuron> WindowsFormsApplication4.web.CreateNetwork ()
функция, необходимая для создания нейронной сети 
string WindowsFormsApplication4.web.determinant (double  w[,])
функция, сравнивающая нейроны с изображением 
Аргументы:
w 	массив весов образа 
void WindowsFormsApplication4.web.save ()
функция, сохраняющая сеть нейронов в текстовый файл 
void WindowsFormsApplication4.web.training (string  nameofneur, double  form[,])
функция, тренирующая нейрон из нейронной сети по определённому имени и массиву весов 
Аргументы:
nameofneur 	имя нейрона 
form 	массив весов нейрона 

Объявления и описания членов класса находятся в файле:
•	web.cs

3. Алгоритмические обеспечение.
3.1. Описание используемых алгоритмов и их назначения.
Для обучения искусственной нейронной сети мы использовали метод обратного распространения ошибки. В качестве функции активации была функция Ферми (экспоненциальная функция):  , где
s – значение элемента, полученного из матричного кода, который соответствует пикселю (0 или 1);
a – коэффициент “сглаживания” сигмоидальной функции (alpha).
Вот её график:
   , т.е. веса нейрона существуют в данном диапазоне 0<=W<=1.
Функция, демонстрирующая работу алгоритма, реализованного в отрывке кода :
      for (int i = 0; i < form.GetLength(0); i++) // цикл по строкам массива
      {
           for (int j = 0; j < form.GetLength(0); j++) // цикл по столбцам массива
           {
                 f = 1.0 / (1.0 + Math.Exp(-a * form[i, j])); // расчёт функции активации
                 weight[i, j] = (weight[i, j] + f) / 2; // пересчёт каждого веса нейрона с учётом функции активации
            }
      }
Для распознавания образа используем алгоритм наименьшего среднеквадратичного отклонения (RMSE). Формула RMSE:
 , где
n – количество пикселей;
  - i-й элемент матричного кода, который соответствует пикселю эталонного образа;
  - i-й элемент матричного кода, который соответствует пикселю полученного образа. 
Отрывок кода, который показывает подсчет RMSE:
double sum = 0; // переменная, необходимая для расчёта среднеквадратичного отклонения типа double
     for (int i = 0; i < weight.GetLength(0); i++) // цикл по строкам массива
          for (int j = 0; j < weight.GetLength(1); j++) // цикл по столбцам массива
              sum += Math.Pow((w[i, j] - weight[i, j]), 2); // суммирование отклонений соответствующих весов
sum /= weight.GetLength(0) * weight.GetLength(1); // среднее суммы 
sum = Math.Sqrt(sum); // корень из среднего суммы (конечный результат расчёта среднеквадратичного отклонения весов нейрона и образа)
Отрывок кода, который показывает работу выборки наименьшего среднеквадратичной ошибки:
neuron n = nnet.Find(v => v.name.Equals(nameofneur)); // экземпляру n присваивается результат нахождения нейрона по имени из нейронной сети
if (n != null) // если нейрон по имени нашёлся
n.training(form); // тренируем найденный нейрон
else
{
    n = new neuron(); // в ином случае создаётся новый экземпляр класса neuron
    n.name = nameofneur; // новому нейрону присваивается имя
    n.count = 0; // обнуляется число обучений нейрона
    n.weight = new double[20, 20]; // создаётся массив весов для нейрона размерностью 20x20
    n.training(form); // новый нейрон тренируется по аргументу (по массиву весов)
    nnet.Add(n); // в сеть нейронов добавляется новый экземпляр 
    save(); // изменённая сеть перезаписывается в текстовый файл
 }
Для обрезки изображения используем функцию CutImg()
Отрывок кода данной функции
Bitmap img2 = new Bitmap(x2 - x1 + 1, y2 - y1 + 1); // переменная результирующего изображения размерностью изображения символа
for (int i = x1; i <= x2; i++) // цикл по строкам
     for (int j = y1; j <= y2; j++) // цикл по столбцам
           img2.SetPixel(i - x1, j - y1, img.GetPixel(i, j)); // закрашиваем соответствующий пиксель в переменной img2 из img
Для сужения или расширения изображения используется функция const_exp()
Часть кода, показывающая работу функции :
for (int x = 0; x < cimg.Height; x++) // цикл по строкам
{
    	for (int y = 0; y < cimg.Height; y++) // цикл по столбцам
       {
             if (count != 0) // пока есть пиксели, которые перезаписываются в результирующее изображение (счётчик не равен нулю)
              {
                   res.SetPixel(x, y, cimg.GetPixel(x, y)); // пикселю результирующего изображения присваивается соответствующий пиксель из обрезанного изображения
                    count--; // уменьшение значения счётчика
              }
              else
                   res.SetPixel(x, y, Cbgr); // в ином случае пикселю результирующего изображения присваивается цвет фона
         }
 }
 res = new Bitmap(res, size); // результирующе изображение пересоздаётся в соответствии с заранее установленным размером
 
 else
 {
     .......
     res = new Bitmap(res, size); // результирующе изображение пересоздаётся в соответствии с заранее установленным размером
 }




3.2. Теоретическое обоснование сложности.
Для того, чтобы определить сложность работы каждого алгоритма и программы в целом следует ввести обозначения.
Пусть :
k - кол-во образов, отправленных на распознавание программой
size - размер изображения (число пикселей в изображении)
n - число нейронов, хранящихся в памяти
sizen - размерность массива весов нейрона = const = 20x20 = 400
Тогда :
equal(){	O(1)	


O(1)	













































O(size*n*k)
int dr = Math.Abs(a.R - b.R);	O(1)		
int dg = Math.Abs(a.G - b.G);	O(1)		
int db = Math.Abs(a.B - b.B);	O(1)		
Return dr + dg + db <= threshold;	O(1)		
}			
BitmapToArr(Bitmap img){	O(size)	









































O(size)



	
for (int i = 0; i < arr.GetLength(0); i++) {	O(sH)		
for (int j = 0; j < arr.GetLength(1); j++){	O(sW)		
if (equal(img.GetPixel(i, j), Cbgr, COLOR_THRESHOLD))	O(1)		
arr[i, j] = 0;	O(1)		
else{ Color Cpxl = img.GetPixel(i, j);
                    	O(1)		
srR += Math.Abs(img.GetPixel(i, j).R);
srG += Math.Abs(img.GetPixel(i, j).G);
srB += Math.Abs(img.GetPixel(i, j).B);
srA += Math.Abs(img.GetPixel(i, j).A);
sc++;
arr[i, j] = 1;	


O(1)		
srR /= sc; srG /= sc; srB /= sc; srA /= sc;
if (srA > 255) srA = 255;
if (srR > 255) srR = 255;
if (srG > 255) srG = 255;
if (srB > 255) srB = 255;
return arr;}	O(1)		
public void ImgProc(){	O(size)		
for (int x = 0; x < imgarr.GetLength(0) && x1 == -1; x++)
for (int y = 0; y < imgarr.GetLength(1) && x1 == -1; y++)
if (imgarr[x, y] == 1)
x1 = x;
for (int y = 0; y < imgarr.GetLength(1) && y1 == -1; y++)
for (int x = 0; x < imgarr.GetLength(0) && y1 == -1; x++)
if (imgarr[x, y] == 1)
y1 = y;
for (int x = imgarr.GetLength(0) - 1; x >= 0 && x2 == -1; x--)
for (int y = 0; y < imgarr.GetLength(1) && x2 == -1; y++)
if (imgarr[x, y] == 1)
x2 = x;
for (int y = imgarr.GetLength(1) - 1; y >= 0 && y2 == -1; y--)
for (int x = 0; x < imgarr.GetLength(0) && y2 == -1; x++)
if (imgarr[x, y] == 1)
y2 = y;	

O(sH*sW)		
if (x1 == -1 || x2 == -1 || y1 == -1 || y2 == -1)              Console.WriteLine("err1");
return;
}	O(1)		
int n = x2 - x1 + 1, m = y2 - y1 + 1;	O(1)		
if (n == m && n == 20)
{
for (int i = x1; i <= x2; i++)
{
     for (int j = y1; j <= y2; j++)
     {
         arrnumb[i, j] = imgarr[i, j];
     }
}
}	O(20*20)≈ O(1)		
const_exp()	3*O(sH*sW) = 3O(size) = O(size)


		
if (cimg.Height > cimg.Width) 	O(1)		
res = new Bitmap(cimg.Height, cimg.Height);	O(1)		
for (int x = 0; x < cimg.Height; x++){	O(sH)		
for (int y = 0; y < cimg.Height; y++){	O(sW)		
if (count != 0)
{
     res.SetPixel(x,y, cimg.GetPixel(x, y));
     count--;
}	O(1)		
else
              res.SetPixel(x, y, Cbgr);	O(1)		
res = new Bitmap(res, size);	O(1)		
else
{
   res = new Bitmap(cimg.Width, cimg.Width);	O(1)		
for (int y = 0; y < cimg.Width; y++){	O(sH)		
for (int x = 0; x < cimg.Width; x++){	O(sW)		
if (count != 0)
{
                               res.SetPixel(x, y, cimg.GetPixel(x, y));
     count--;
}	O(1)		
else
                            res.SetPixel(x, y, Cbgr);	O(1)		
res = new Bitmap(res, size);	O(1)		
if (resimg != null){
arrnumb = BitmapToArr(resimg);
}	O(size)		
return res;	O(1)		
public string determinant(double[,] w)	O(n)	
O(k*n)	
string name = "I can not determine";	O(1)		
double k1 = 1;	O(1)		
double k2;	O(1)		
foreach(neuron n in nnet)	O(nnet.Length) = O(n)		
k2 = n.MSE(w);	O(sizen) =O(20*20) ≈ O(1)		
if (k2 < k1)
{
      k1 = k2;
      name = n.name;
}    	O(1)		
return name;	O(1)		
resultat(web web)	O()		
Console.Write("\n" + count + "\n");	O(1)		
string text = "";	O(1)		
if (web.nnet.Count == 0){	O(1)		
Console.WriteLine("err web = null");	O(1)		
text = "нейронная сеть пуста";	O(1)		
return text;}	O(1)		
text = "Информация о видео файле :\r\nWidth: " + width + "\r\nheight: " + heigth + "\r\ncodec: " + codec + "\r\nfps: " + fps + "\r\nЧисло кадров в видеофайле: " + frameCount + "\n\r";	O(1)		
foreach (picture p in videoweb)	O(k)		
text += "\r\n\r\nобраз - " + p.filename + ":\r\nЦвет фона :" + p.Cbgr + "\r\nЦвет символа :Color [A=" + p.srA + ", R=" + p.srR + ", G=" + p.srG + ", B=" + p.srB + "]\r\nРезультат " + ": " + web.determinant(p.arrnumb) + "\r\n";	O(n)		
return text;	O(1)		
В итоге общая сложность программы получилась следующей:
O(size * n * k)
Поскольку размер видеофайла равен 255x255 и число нейронов равно 10 (потому что определяем только числа), то сложность программы упрощается и становится линейной :
O(k)

















3.3. Эмпирическое обоснование сложности.
Возьмём несколько видеофайлов одинаковых размеров
число изображений	время обработки(мс)
2	864
4	2228
8	4812
16	7348
32	17135
64	38072
128	78270
	

 
На графике видно, что реальные результаты практически сходятся с теоретическими. Время обработки в программе высчитывалось с помощью таймера (использовался класс Stopwatch)






4. Тестирование.
4.1. Описание unit-тестов.
Для проверки корректности работы алгоритма распознавания образов, создадим unit-test. В качестве входных данных возьмём на обработку видеофайл, содержащий 16 образов, фон и символ каждого из которых могут быть различными.
Сопоставим результаты обработки образов нейронной сетью
 
образ - 1.bmp:
Цвет фона :Color [A=255, R=255, G=255, B=255]
Цвет символа :Color [A=255, R=249, G=15, B=14]
Результат : 4
образ - 2.bmp:
Цвет фона :Color [A=255, R=255, G=255, B=255]
Цвет символа :Color [A=255, R=26, G=26, B=26]
Результат : 7
образ - 3.bmp:
Цвет фона :Color [A=255, R=255, G=255, B=255]
Цвет символа :Color [A=255, R=41, G=41, B=41]
Результат : 7
образ - 4.bmp:
Цвет фона :Color [A=255, R=255, G=255, B=255]
Цвет символа :Color [A=255, R=20, G=20, B=20]
Результат : 1
образ - 5.bmp:
Цвет фона :Color [A=255, R=255, G=255, B=255]
Цвет символа :Color [A=255, R=4, G=4, B=4]
Результат : 0
образ - 6.bmp:
Цвет фона :Color [A=255, R=255, G=255, B=255]
Цвет символа :Color [A=255, R=250, G=9, B=9]
Результат : 2
образ - 7.bmp:
Цвет фона :Color [A=255, R=255, G=255, B=255]
Цвет символа :Color [A=255, R=20, G=132, B=133]
Результат : 3
образ - 8.bmp:
Цвет фона :Color [A=255, R=255, G=255, B=255]
Цвет символа :Color [A=255, R=29, G=29, B=240]
Результат : 4
образ - 9.bmp:
Цвет фона :Color [A=255, R=255, G=255, B=255]
Цвет символа :Color [A=255, R=133, G=133, B=133]
Результат : 5
образ - 10.bmp:
Цвет фона :Color [A=255, R=255, G=255, B=255]
Цвет символа :Color [A=255, R=14, G=252, B=251]
Результат : 9
образ - 11.bmp:
Цвет фона :Color [A=255, R=0, G=0, B=0]
Цвет символа :Color [A=255, R=240, G=1, B=1]
Результат : 2
образ - 12.bmp:
Цвет фона :Color [A=255, R=255, G=255, B=255]
Цвет символа :Color [A=255, R=246, G=18, B=18]
Результат : 4
образ - 13.bmp:
Цвет фона :Color [A=255, R=0, G=0, B=0]
Цвет символа :Color [A=255, R=249, G=252, B=252]
Результат : 1
образ - 14.bmp:
Цвет фона :Color [A=255, R=0, G=0, B=0]
Цвет символа :Color [A=255, R=239, G=239, B=239]
Результат : 7
образ - 15.bmp:
Цвет фона :Color [A=255, R=255, G=255, B=255]
Цвет символа :Color [A=255, R=20, G=19, B=20]
Результат : 8
образ - 16.bmp:
Цвет фона :Color [A=255, R=255, G=255, B=255]
Цвет символа :Color [A=255, R=14, G=14, B=14]
Результат : 0
Как видно из результатов, нейронная сеть не смогла распознать сложные образы 2 и 3, остальные были определены верно, включая цвета фона и самого числа. Чтобы распознать более сложные образы, необходимо тренировать нейронную сеть, на что может понадобиться некоторое время.
5. Выводы.
В ходе выполнения курсовой работы:
•	была рассмотрена искусственная нейронная сеть (ИНС) с теоретической и практической стороны.
•	были рассмотрены новые методы для работы с видеофайлами.
•	были рассмотрены новые методы для работы с изображениями.
Результатом данной курсовой работы стала программа, распознающая образы из видеофайла при помощи ИНС. Изначально программа принимает видеофайл и разделяет его на кадры, сохраняя их в формате BMP, используя библиотеку AForge. Далее мы декодируем предоставленные изображения из представленного формата BMP в матричный код для последующей работы с ним. Производится анализ незнакомого образа, который пропускается через искусственную нейронную сеть, сравнивается с каждым эталонным образом, в результате выявляется среднеквадратичная ошибка. Тем меньше данная ошибка, тем ближе его принадлежность к определенному образу.
Также в данной программе можно обучить нейронную сеть при помощи метода обратного распространения ошибки. В качестве функции активации используется функция Ферми (экспоненциальная сигмоида). Образ в нейронную сеть отправляется при помощи графического редактора.

6. Приложения.
6.1. Приложение 1. Руководство пользователя.
После запуска приложения перед вами появится следующее окно :
 

Содержимое окна :
•	Кнопка «Open video file»
•	Кнопка «Get result»
•	Кнопка «training»
•	Поле для ввода
•	Поле для вывода

Для тренировки нейронной сети введите в поле имя нейрона, который вы хотите натренировать, и нажмите на кнопку «training»
 
Перед вами откроется диалоговое окно, в котором вы сможете выбрать необходимый вам образ, далее нажмите открыть
В случае успешного завершения обработки программа должна вывести пользователю сообщение :
 

Если нейронная сеть достаточно натренирована, чтобы распознать необходимые вам образы, нажмите на кнопку «Open video file» и перед вами появится окно, в котором вы должны выбрать видеофайл
 
После открытия необходимого для обработки видеофайла, нажмите на кнопку «Get result», чтобы получить результат
 
В итоге, в поле для вывода вы должны увидеть информацию о выбранном видеофайле  и кадрах, взятых из него за каждую секунду
6.2. Приложение 2. Исходный код.
Класс Form3.cs 

using System;
using System.Drawing;
using System.Windows.Forms;

namespace WindowsFormsApplication4
{
    /*!
            \brief класс интерфейса
    */
    public partial class Form3 : Form
    {
        /// нейронная сеть
        web web = new web();
        /// экземпляр класса video для обработки видеофайла
        video video = null;
        /// переменная, которая должна получить результат сравнения нейронов с образами и информации о видеофайле
        string text = "";
        /// filetrain - переменная, необходимая для хранения пути к образу, которому мы хотим научить нейронную сеть
        string filetrain = "";
        ///train - экземпляр класса picture для тренировки нейронной сети
        picture train;
        /// string nametrain - имя тренируемого нейрона
        string nametrain = "";
        /// путь к видео файлу
        string videoname;

        /*!
            * конструктор класса Form3
        */
        public Form3()
        {
            InitializeComponent();
        }
        /*!
            * функция, обрабатывающая нажатие кнопки button3 для тренировки нейронной сети
            \param sender объект, который вызвал событие
            \param e класс, дающий возможность передать какую-нибудь дополнительную информацию обработчику
        */
        private void button3_Click(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog(); // экземпляр диалогового окна
            openFileDialog1.Filter = "Video Files(*.WMV;*.AVI;*.MP4)|*.WMV;*.AVI;*.MP4|All files (*.*)|*.*"; // фильтр экземпляра диалогового окна
            openFileDialog1.FilterIndex = 2; // задается индекс текущего фильтра.
            openFileDialog1.RestoreDirectory = true; // сохранение последнего пути
            if (openFileDialog1.ShowDialog() == DialogResult.OK) // при нажатии на кнопку "OK"
            {
                filetrain = openFileDialog1.FileName; // переменной filetrain присваивается путь к образу
                nametrain = textBox1.Text; // переменной nametrain присваивается имя обучаемого нейрона
            }
            if (filetrain != null && filetrain.Equals("") != true && nametrain.Equals("") != true && nametrain != null) // если имя нейрона и путь к образу не пустые
            {
                train = new picture(filetrain); // создаётся экземпляр класса train
                web.training(nametrain, train.arrnumb); // сеть тренирует нейрон с именем nametrain по массиву весов train.arrnumb
                web.save(); // нейронная записывается в текстовый файл
                MessageBox.Show("Обработка завершена !", ""); // вывод сообщения о том, что обработка завершена
                train = null; // экземпляр train принимает значение по умолчанию
                filetrain = null; // filetrain принимает значение по умолчанию
                nametrain = null; // nametrain принимает значение по умолчанию
            }
        }
        /*!
            * функция, обрабатывающая нажатие кнопки button1 для вывода диалогового окна с целью записи пути к видеофайлу
            \param sender объект, который вызвал событие
            \param e класс, дающий возможность передать какую-нибудь дополнительную информацию обработчику
        */
        private void button1_Click(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog(); // экземпляр диалогового окна
            openFileDialog1.Filter = "Video Files(*.WMV;*.AVI;*.MP4)|*.WMV;*.AVI;*.MP4|All files (*.*)|*.*"; // фильтр экземпляра диалогового окна
            openFileDialog1.FilterIndex = 2; // задается индекс текущего фильтра.
            openFileDialog1.RestoreDirectory = true; // сохранение последнего пути
            if (openFileDialog1.ShowDialog() == DialogResult.OK) // при нажатии на кнопку "OK"
                videoname = openFileDialog1.FileName; // переменной videoname присваивается путь к видеофайлу
        }
        /*!
           * функция, обрабатывающая нажатие кнопки button2 для вывода результата обработки видеофайла нейронной сетью
           \param sender объект, который вызвал событие
           \param e класс, дающий возможность передать какую-нибудь дополнительную информацию обработчику
       */
        private void button2_Click(object sender, EventArgs e) // 
        {
            if (videoname == null || videoname.Equals("") == true) // если путь к видеофайлу пуст
                MessageBox.Show("Видео файл не обработан", ""); // вывод сообщения о том, что видеофайл не смог обработаться
            else
            {
                Console.WriteLine(videoname); // вывод пути к видеофайлу в консоль
                video = new video(videoname); // создание экземпляра класса video
                text = video.resultat(web); // запись результата сравнения нейронов и образов из видеофайла в переменную text
                TextBox t = textBox2; // объект TextBox t
                t.Text = text; // присвоение полю TextBox значения переменной text
                textBox2.Refresh(); // обновление поля textBox2
                MessageBox.Show("Обработка завершена !", ""); // вывод на экран сообщения о том, что обработка завершена
            }
        }
        /*!
          * метод, обрабатывающий изменение текста поля textBox2
          \param sender объект, который вызвал событие
          \param e класс, дающий возможность передать какую-нибудь дополнительную информацию обработчику
        */
        private void textBox2_TextChanged(object sender, EventArgs e) // 
        {
            textBox2.Text = text; // текст в поле textBox2 получает значение переменной text
        }
        /*!
          * функция, обрабатывающая изменение текста поля textBox1
          \param sender объект, который вызвал событие
          \param e класс, дающий возможность передать какую-нибудь дополнительную информацию обработчику
        */
        private void textBox1_TextChanged(object sender, EventArgs e) // 
        {
        }
        /*!
          * функция, обрабатывающая загрузку интерфейса
          \param sender объект, который вызвал событие
          \param e класс, дающий возможность передать какую-нибудь дополнительную информацию обработчику
        */
        private void Form3_Load(object sender, EventArgs e) // метод, загружающий Form3
        {    
        }    
    }
} 
 
Класс neuron.cs
using System;

namespace WindowsFormsApplication4 // пространство имён WindowsFormsApplication4
{
    /*!
        * класс нейрона
    */
    public class neuron
    {
        /// коэффициент альфа, применяется для расчёта функции активации
        public const double a = 1.0;
        /// имя нейрона типа string
        public string name;
        /// число обучений нейрона
        public int count;
        /// двумерный массив весов нейрона
        public double[,] weight;
        /*!
            * функция, тренирующая нейрон по входному изображению с помощью функции активации
            \param form Массив весов образа
        */
        public void training(double[,] form) 
        {
            double f = 0.0; // переменная, необходимая для расчёта функции активации
            if (weight.GetLength(0) == form.GetLength(0) && weight.GetLength(1) == form.GetLength(1)) // если размерность массивов, хранящих весы у образа и нейрона равны, то переходим к циклу
                for (int i = 0; i < form.GetLength(0); i++) // цикл по строкам массива
                {
                    for (int j = 0; j < form.GetLength(0); j++) // цикл по столбцам массива
                    {
                        f = 1.0 / (1.0 + Math.Exp(-a * form[i, j])); // расчёт функции активации
                        weight[i, j] = (weight[i, j] + f) / 2; // пересчёт каждого веса нейрона с учётом функции активации
                    }
                }
            count++; // прибавление кол-ва тренировок нейрона на 1
        }
        /*!
            * double функция, высчитывающая среднеквадратинчое отклонение весов нейрона от весов входного изображения
            \param w Массив весов образа
            \return sum результат среднеквадратичного отклонения
        */
        public double MSE(double[,] w)
        {
            double sum = 0; // переменная, необходимая для расчёта среднеквадратичного отклонения типа double
            for (int i = 0; i < weight.GetLength(0); i++) // цикл по строкам массива
                for (int j = 0; j < weight.GetLength(1); j++) // цикл по столбцам массива
                    sum += Math.Pow((w[i, j] - weight[i, j]), 2); // суммирование отклонений соответствующих весов
            sum /= weight.GetLength(0) * weight.GetLength(1); // среднее суммы 
            sum = Math.Sqrt(sum); // корень из среднего суммы (конечный результат расчёта среднеквадратичного отклонения весов нейрона и образа)
            return sum; // возвращение значения результата функцией
        }
        /*!
            * функция, которая создаёт нейрон по строке s
            \param s строка, по которой будет создаваться нейрон
            \return this полученный нейрон
        */
        public neuron CreateN(string s)
        {
            string[] s2 = s.Split(' '); // одномерный массив, служащий для разбора строки s
            this.name = s2[0]; // присвоение имени обрабатываемому нейрону
            this.count = Int32.Parse(s2[1]); // присвоение кол-ва обучений обрабатываемому нейрону
            int n = (int)(Math.Sqrt(s2.Length - 2)); // расчёт размерности массива весов нейрона
            this.weight = new double[n, n]; // инициализация массива весов нейрона типа double
            for (int i = 0; i < n; i++) // цикл по строкам
                for (int j = 0; j < n; j++) // цикл по столбцам
                    this.weight[i, j] = double.Parse(s2[i * n + j + 2]); // присвоение значения веса нейрона элементу массива весов
            return this; // возвращение нейрона функцией
        }
    }
}

Класс picture.cs
using System;
using System.Drawing;

namespace WindowsFormsApplication4 // пространство имён WindowsFormsApplication4
{
    /*!
       * класс, обрабатывающий изображение
    */
    public class picture
    {
        /// переменная, служащая для хранения цвета фона
        public Color Cbgr;
        /// переменная, необходимая для расчёта приближённого красного оттенка цвета символа (среднее значение)
        public int srR = 0;
        /// переменная, необходимая для расчёта приближённого зелёного оттенка цвета символа (среднее значение)
        public int srG = 0;
        /// переменная, необходимая для расчёта приближённого синего оттенка цвета символа (среднее значение)
        public int srB = 0;
        /// переменная, необходимая для расчёта приближённого значения прозрачности цвета символа (среднее значение)
        public int srA = 0;
        /// переменная для хранения начального изображения
        public Bitmap img;
        /// переменная для хранения обрезанного изображения
        public Bitmap cimg;
        /// переменная для хранения конечного изображения
        public Bitmap resimg;
        /// двумерный массив весов начального изображения
        public double[,] imgarr;
        /// двумерный массив весов конечного изображения размерностью 20x20
        public double[,] arrnumb = new double[20, 20];
        /// путь к изображению для Bitmap img
        public string filename;
        /// переменные типа integer, необходимые для хранения координат левой верхней и правой нижней точек символа
        public int x1, y1, x2, y2;
        /// экземпляр класса random, необходимый для получения случайных чисел
        Random rand = new Random();
        /// переменная, являющаяся границей для определения цвета
        public const int COLOR_THRESHOLD = 64;

        /*!
           *функция, которая проверяет, не вышел ли цвет за максимально допустимое значение treshold
           \param a переменная, хранящая цвет, для сравнения с переменной "b"
           \param b 2ая переменная, хранящая цвет, для сравнения с переменной "a"
           \param threshold граничное значение
           \return возвращение результата проверки функции
       */
        public static bool equal(Color a, Color b, int threshold)
        {
            int dr = Math.Abs(a.R - b.R); // переменная типа integer, принимающая числовое значение разности красных оттенков цветов a и b
            int dg = Math.Abs(a.G - b.G); // переменная типа integer, принимающая числовое значение разности зелёных оттенков цветов a и b
            int db = Math.Abs(a.B - b.B); // переменная типа integer, принимающая числовое значение разности синих оттенков цветов a и b
            return dr + dg + db <= threshold; // возвращение результата проверки функции
        }
        /*!
           *конструктор класса picture
           \param filename путь к изображению
       */
        public picture(string filename)
        {
            x1 = -1; y1 = -1; x2 = -1; y2 = -1; // начальные значения координат
            this.filename = filename; // присвоение пути к файлу переменной filename
            img = new Bitmap(filename); // запись начального изображения в объект img
            Cbgr = img.GetPixel(0, 0); // присвоение цвета фона переменной Cbgr
            imgarr = BitmapToArr(img); // получение переменной imgarr массива весов по начальному изображению
            ImgProc(); // вызов функции ImgProc() для обработки изображения
            resimg.Save(rand.Next(0, 100) + "picture.bmp");
        }
        /*!
            *double функция, преобразующая Bitmap изображение в массив весов
            \param img изображение, которое нужно преобразовать в массив весов
       */
        public double[,] BitmapToArr(Bitmap img)
        {
            double[,] arr;
            int sc = 0; // счётчик типа integer, необходимый для расчёта кол-ва пикселей, у которых цвет похож на цвет символа в обрабатываемом изображении
            arr = new double[img.Width, img.Height]; // массив весов
            for (int i = 0; i < arr.GetLength(0); i++) // цикл по строкам
            {
                for (int j = 0; j < arr.GetLength(1); j++) // цикл по столбцам
                {
                    if (equal(img.GetPixel(i, j), Cbgr, COLOR_THRESHOLD)) // проверка пикселя на цвет фона или символа
                        arr[i, j] = 0; // значению эл-а массива весов присваивается 0, т.е. условно считается, что пиксель изображения по цвету принадлежит к фоновому
                    else
                    {
                        Color Cpxl = img.GetPixel(i, j); // в переменную Cpxl типа Color заносим цвет текущего пикселя
                        srR += Math.Abs(img.GetPixel(i, j).R); // передача численного значения красного оттенка текущего пикселя в переменную srR
                        srG += Math.Abs(img.GetPixel(i, j).G); // передача численного значения зелёного оттенка текущего пикселя в переменную srG
                        srB += Math.Abs(img.GetPixel(i, j).B); // передача численного значения синего оттенка текущего пикселя в переменную srB
                        srA += Math.Abs(img.GetPixel(i, j).A); // передача численного значения прозрачности текущего пикселя в переменную srA
                        sc++; // прибавление счётчику 1
                        arr[i, j] = 1; // значению веса эл-а массива присваивается 1 (оно соответствует пикселю, который по цвету принадлежит символу)
                    }
                }
            }
            srR /= sc; srG /= sc; srB /= sc; srA /= sc; // средние значения оттенков цвета символа и прозрачности цвета
            if (srA > 255) srA = 255; // если значение прозрачности вышло за диапазон максимально допустимого, присваиваем переменной максимально допустимое значение
            if (srR > 255) srR = 255; // если значение красного оттенка вышло за диапазон максимально допустимого, присваиваем переменной максимально допустимое значение
            if (srG > 255) srG = 255; // если значение зелёного оттенка вышло за диапазон максимально допустимого, присваиваем переменной максимально допустимое значение
            if (srB > 255) srB = 255; // если значение синего оттенка вышло за диапазон максимально допустимого, присваиваем переменной максимально допустимое значение
            return arr; // возвращение массива весов
        }
        /*!
            *double функция, необходимая для обработки изображения (нахождение координат левой верхней и правой нижней точек символа; обрезка изображения по полученным координатам; получение конечного изображения размера 20x20 из обрезанного)
        */
        public void ImgProc()
        {
            for (int x = 0; x < imgarr.GetLength(0) && x1 == -1; x++) // цикл по строкам с дополнительным условием x1 == -1
                for (int y = 0; y < imgarr.GetLength(1) && x1 == -1; y++) // цикл по столбцам с дополнительным условием x1 == -1
                    if (imgarr[x, y] == 1) // если эл-т массива весов равен 1
                        x1 = x; // присваиваем переменной x1 значение координаты крайней левой точки символа
            for (int y = 0; y < imgarr.GetLength(1) && y1 == -1; y++) // цикл по столбцам с дополнительным условием y1 == -1
                for (int x = 0; x < imgarr.GetLength(0) && y1 == -1; x++) // цикл по строкам с дополнительным условием y1 == -1
                    if (imgarr[x, y] == 1) // если эл-т массива весов равен 1
                        y1 = y; // присваиваем переменной y1 значение координаты крайней верхней точки символа
            for (int x = imgarr.GetLength(0) - 1; x >= 0 && x2 == -1; x--) // цикл с конца по строкам с дополнительным условием x2 == -1
                for (int y = 0; y < imgarr.GetLength(1) && x2 == -1; y++) // цикл по столбцам с дополнительным условием x2 == -1
                    if (imgarr[x, y] == 1) // если эл-т массива весов равен 1
                        x2 = x; // присваиваем переменной x2 значение координаты крайней правой точки символа
            for (int y = imgarr.GetLength(1) - 1; y >= 0 && y2 == -1; y--) // цикл с конца по столбцам с дополнителным условием y2 == -1
                for (int x = 0; x < imgarr.GetLength(0) && y2 == -1; x++) // цикл по строкам с дополнительным условием y2 == -1
                    if (imgarr[x, y] == 1) // если эл-т массива весов равен 1
                        y2 = y; // присваиваем переменной y2 значение координаты крайней нижней точки символа
            if (x1 == -1 || x2 == -1 || y1 == -1 || y2 == -1) // если какая-либо из координат не нашлась в цикле
            {
                Console.WriteLine("err1"); // вывод оповещения об ошибке в консоль
                return; // выход из функции
            }
            int n = x2 - x1 + 1, m = y2 - y1 + 1; // переменые, численно равные размерам изображения символа
            if (n == m && n == 20) // если размеры изображения уже равны 20x20
            {
                for (int i = x1; i <= x2; i++) // цикл по строкам
                {
                    for (int j = y1; j <= y2; j++) // цикл по столбцам
                    {
                        arrnumb[i, j] = imgarr[i, j]; // эл-ту массива весов конечного изображения присваивается соответствующее значение эл-а из массива весов начального изображения
                    }
                }
            }
            cimg = CutImg(); // получение обрезанного изображения в результате выполнения функции CutImg()
            if (n != 20 || m != 20) // если ширина или длина изображения символа не равна 20
            {
                resimg = const_exp(); // получение суженного или расширенного изображения в результате выполнения функции const_exp()
            }
            if (resimg != null) // если Bitmap конечного изображения не равен null
                arrnumb = BitmapToArr(resimg); // по конечному изображению создаётся массив весов конечного изображения
            else
            {
                Console.WriteLine("err2"); // в ином случае в консоль выводится оповещение об ошибке
                return; // выход из функции
            }
        }
        /*!
            * функция, обрезающая изображение
        */
        public Bitmap CutImg()
        {
            Bitmap img2 = new Bitmap(x2 - x1 + 1, y2 - y1 + 1); // переменная результирующего изображения размерностью изображения символа
            for (int i = x1; i <= x2; i++) // цикл по строкам
                for (int j = y1; j <= y2; j++) // цикл по столбцам
                    img2.SetPixel(i - x1, j - y1, img.GetPixel(i, j)); // закрашиваем соответствующий пиксель в переменной img2 из img
            return img2; // возвращаем результат обрезки изображения
        }
        /*!
            * функция, по необходимости сужающая или расширяющая обрезанное изображение
        */
        public Bitmap const_exp() // 
        {
            Bitmap res = null; // переменная Bitmap, в которую запишется результат сужения или расширения изображения
            Size size = cimg.Size; // перменная типа size, необходимая для определения размеров будущего изображения
            size.Height = 20; size.Width = 20; // определение размеров результирующего изображения
            int count = cimg.Height * cimg.Width; // общее число пикселей в обрезанном изображении (счётчик)
            if (cimg.Height > cimg.Width) // если высота изображения больше ширины
            {
                res = new Bitmap(cimg.Height, cimg.Height); // результирующее изображение будет иметь размерность высота на высоту от обрезанного изображения
                for (int x = 0; x < cimg.Height; x++) // цикл по строкам
                {
                    for (int y = 0; y < cimg.Height; y++) // цикл по столбцам
                    {
                        if (count != 0) // пока есть пиксели, которые перезаписываются в результирующее изображение (счётчик не равен нулю)
                        {
                            res.SetPixel(x, y, cimg.GetPixel(x, y)); // пикселю результирующего изображения присваивается соответствующий пиксель из обрезанного изображения
                            count--; // уменьшение значения счётчика
                        }
                        else
                            res.SetPixel(x, y, Cbgr); // в ином случае пикселю результирующего изображения присваивается цвет фона
                    }
                }
                res = new Bitmap(res, size); // результирующе изображение пересоздаётся в соответствии с заранее установленным размером
            }
            else
            {
                res = new Bitmap(cimg.Width, cimg.Width); // результирующее изображение будет иметь размерность ширина на ширину от обрезанного изображения
                for (int y = 0; y < cimg.Width; y++) // цикл по столбцам
                {
                    for (int x = 0; x < cimg.Width; x++) // цикл по строкам
                    {
                        if (count != 0) // пока есть пиксели, которые перезаписываются в результирующее изображение (счётчик не равен нулю)
                        {
                            res.SetPixel(x, y, cimg.GetPixel(x, y)); // пикселю результирующего изображения присваивается соответствующий пиксель из обрезанного изображения
                            count--; // уменьшение значения счётчика
                        }
                        else
                            res.SetPixel(x, y, Cbgr); // в ином случае пикселю результирующего изображения присваивается цвет фона
                    }
                }
                res = new Bitmap(res, size); // результирующе изображение пересоздаётся в соответствии с заранее установленным размером
            }
            return res; // возвращение значения функцией (результирующего изображения)
        }
    }

Класс video.cs

using AForge.Video.FFMPEG;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;

namespace WindowsFormsApplication4 // пространство имён WindowsFormsApplication4
{
    /*!
        * класс, предназначенный для обработки видеофайлов
    */
    class video : IDisposable
    {
        /// экземпляр List<picture> для хранения кадров видеофайла
        public List<picture> videoweb = new List<picture>();
        /// экземпляр VideoFileReader для считывания кадров из видеофайла и получения дополнительной информации о нём
        public VideoFileReader reader = new VideoFileReader();
        /// переменная типа integer, необходимая для хранения индекса последнего сохранённого изображения
        public int index;
        ///счётчик (считающий кол-во обрабатываемых кадров из видеофайла) 
        int count = 0;
        ///информация о ширине видеофайла
        int width;
        ///heigth - информация о высоте видеофайла
        int heigth;
        ///информация о частоте кадров в секунду
        int fps;
        ///информация о кодеке
        string codec;
        /// переменная, хранящая путь к файлу, в котором содержится значение индекса последнего сохранённого изображения.
        const string file = @"index.txt";
        /// переменная типа long, необходимая для хранения кол-ва кадров в видеофале
        long frameCount;
        /*!
             * конструктор класса video
             \param filename путь к видеофайлу
        */
        public video(string filename)
        {
            index = Convert.ToInt32(File.ReadAllText(file)); // из файла index.txt берётся значение integer и записывается в переменную index
            reader.Open(filename); // reader открывает видеофайл
            videoweb = raskadrovka(); // в экземпляр videoweb записывается результат выполнения функции raskadrovka() (лист videoweb получает обработанные кадры из видеофайла)
            System.IO.File.WriteAllText(file, index.ToString()); // запись значения последнего индекса в файл index.txt
        }
        /*!
            * функция, которая получает информацию о видеофайле и делит его на кадры, которые обрабатываются в классе picture и записываются в лист
        */
        public List<picture> raskadrovka()
        {
            width = reader.Width; // получение значения ширины видеофайла
            heigth = reader.Height; // получение значения высоты видеофайла
            fps = reader.FrameRate; // получение частоты видеофайла 
            codec = reader.CodecName; // получение кодека видеофайла
            frameCount = reader.FrameCount; // получение кол-ва кадров в видеофайле
            Console.WriteLine("width:  " + width); // вывод ширины в консоль
            Console.WriteLine("height: " + heigth); // вывод высоты в консоль
            Console.WriteLine("fps:    " + fps); // вывод частоты в консоль
            Console.WriteLine("codec:  " + codec); // вывод информации о кодеке в консоль
            List<picture> res = new List<picture>(); // инициализация экземпляра res
            for (int i = 1; i < reader.FrameCount; i++) // цикл по всем кадрам из видеофайла
            {
                count++; // счётчику прибавляется 1
                Bitmap videoFrame = reader.ReadVideoFrame(); // объект videoFrame получает соответствующее изображение из видеофайла
                if (videoFrame != null && i % fps == 0) // если videoFrame не null и изображение взято на секунде
                {
                    videoFrame.Save(index + ".bmp"); // сохраняем изображение
                    res.Add(new picture(index + ".bmp")); // в результирующий лист записываем экземпляр класса picture
                    index++; // индекс увеличиваем на 1
                }
                videoFrame.Dispose(); // очищение ресурсов
            }
            reader.Close(); // закрытие объекта reader
            return res; // возврщение функцией результирующего листа
        }
        /*!
            * функция, необходимая для вывода результатов сравнения нейронов из нейронной сети с каждым из образов, полученных из видеофайла
            \param web нейронная сеть
        */
        public string resultat(web web)
        {
            Console.Write("\n" + count + "\n"); // вывод кол-ва изображений
            string text = ""; // переменная, в которую будет записываться текст результата
            if (web.nnet.Count == 0) // если в нейронной сети нет нейронов
            {
                Console.WriteLine("err web = null"); // вывод оповещения в консоль об ошибке
                text = "нейронная сеть пуста"; // переменной text присваивается строка с содержанием о том, что в нейронной сети нет нейронов
                return text; // возвращение функцией значения переменной text
            }
            text = "Информация о видео файле :\r\nWidth: " + width + "\r\nheight: " + heigth + "\r\ncodec: " + codec + "\r\nfps: " + fps + "\r\nЧисло кадров в видеофайле: " + frameCount + "\n\r";// запись в переменную text информации о видеофайле
            foreach (picture p in videoweb) // пробегаем по всем нейронам в сети
                text += "\r\n\r\nобраз - " + p.filename + ":\r\nЦвет фона :" + p.Cbgr + "\r\nЦвет символа :Color [A=" + p.srA + ", R=" + p.srR + ", G=" + p.srG + ", B=" + p.srB + "]\r\nРезультат " + ": " + web.determinant(p.arrnumb) + "\r\n"; // результат сравнения образа и нейронов из нейронной сети записываются в переменную text
            return text; // возвращение функцией значения переменной текст
        }
        /*!
            * функция, необходимая для очищения ресурсов
        */
        public void Dispose()
        { 
            throw new NotImplementedException(); // Инициализирует новый экземпляр класса NotImplementedException стандартными свойствами.
        }
    }
}

Класс web.cs

using System;
using System.Collections.Generic;
using System.IO;

namespace WindowsFormsApplication4 // пространство имён WindowsFormsApplication4
{
    /*!
       * класс, обрабатывающий сеть нейронов
    */
    public class web
    {
        /// экземпляр List<neuron> nnet
        public List<neuron> nnet;
        /// путь к файлу memory.txt
        public const string f = @"memory.txt";
        /*!
             * конструктор класса web
        */
        public web()
        {
            nnet = CreateNetwork(); // Создаётся нейронная сеть и записывается в лист nnet
        }
        /*!
             * функция, необходимая для создания нейронной сети
        */
        public List<neuron> CreateNetwork()
        {
            List<neuron> result = new List<neuron>(); // инициализация листа result
            if (!File.Exists(f)) // если файл по пути f не существует
                return result; // возвращение значения result функцией CreateNetwork()
            string[] s = File.ReadAllLines(f); // массив строк s считывает все строки из текстового файла memory.txt
            if (s.GetLength(0) == 0) // если число строк массива s == 0
                return result; // возвращение значения result функцией CreateNetwork()
            foreach (string line in s) // пробегаемся по всем строкам массива s
            {
                neuron n = new neuron(); // инициализация нейрона
                n = n.CreateN(line); // создание нейрона
                result.Add(n); // запись нейрона в сеть нейронов
            }          
            return result; // возвращение значения result функцией CreateNetwork()
        }
        /*!
             * функция, сохраняющая сеть нейронов в текстовый файл
        */
        public void save()
        {
            string s = ""; // переменная, в которую будет записываться информация о нейронах
            foreach (neuron n in nnet) // пробегаемся по всем нейронам 
            {
                s += n.name + " " + n.count.ToString() + " "; // прибавление строке s имени и кол-ва обучений текущего нейрона
                for (int i = 0; i < n.weight.GetLength(0); i++) // цикл по строкам
                    for (int j = 0; j < n.weight.GetLength(1); j++) // цикл по столбцам
                        s += n.weight[i, j].ToString() + " "; // прибавление строке s эл-та массива весов текущего нейрона 
                s += "\r\n"; // прибавление строке s перехода на следующую строку
            }
            System.IO.File.WriteAllText(f, s); // запись значения переменной s в текстовый файл
        }
        /*!
            * функция, тренирующая нейрон из нейронной сети по определённому имени и массиву весов
            \param nameofneur имя нейрона
            \param form массив весов нейрона
        */
        public void training(string nameofneur, double[,] form)
        {
            neuron n = nnet.Find(v => v.name.Equals(nameofneur)); // экземпляру n присваивается результат нахождения нейрона по имени из нейронной сети
            if (n != null) // если нейрон по имени нашёлся
                n.training(form); // тренируем найденный нейрон
            else
            {
                n = new neuron(); // в ином случае создаётся новый экземпляр класса neuron
                n.name = nameofneur; // новому нейрону присваивается имя
                n.count = 0; // обнуляется число обучений нейрона
                n.weight = new double[20, 20]; // создаётся массив весов для нейрона размерностью 20x20
                n.training(form); // новый нейрон тренируется по аргументу (по массиву весов)
                nnet.Add(n); // в сеть нейронов добавляется новый экземпляр 
                save(); // изменённая сеть перезаписывается в текстовый файл
            }
        }
        /*!
            * функция, сравнивающая нейроны с изображением
            \param w массив весов образа
        */
        public string determinant(double[,] w)
        {
            string name = "I can not determine"; // переменная, хранящая имя распознанного нейрона. Если никакой из нейронов не распознался, выводится начальное значение - "не могу определить"
            double k1 = 1; // коэффициент double k1
            double k2; // коэффициент double k2
            foreach(neuron n in nnet) // пробегаемся по всем нейронам из сети
            {
                k2 = n.MSE(w); // в переменную k2 записывается результат обработки функции MSE() (среднеквадратичное отклонение нейрона от изображения)
                if (k2 < k1) // если полученное отклонение меньше текущего
                {
                    k1 = k2; // текущему отклонению присваиваем полученное
                    name = n.name; // переменной name присваиваем имя полученного нейрона
                }        
            }
            return name; // возвращение функцией имени предполагаемого нейрона или вывода сообщения "I can not determine"
        }
    }
}

Класс Program.cs

using System;
using System.Windows.Forms;

namespace WindowsFormsApplication4
{
    /*!
        \brief класс для запуска приложения
    */
    static class Program
    {
        /// <summary>
        /// Главная точка входа для приложения.
        /// </summary>
        [STAThread]
        //! Функция main() − точка входа в программу.
        static void Main()
        { 
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form3()); // Запуск Form3
        }
    }
}
